# create point patterns
# http://mapas.mma.gov.br/i3geo/pacotes/rlib/win/spatstat/html/owin.html

### import libraries
library(spatstat)  # statistical point pattern analysis
library(car) # class. statistics
library(MASS)
library(extrafont)  # fonts for latex pdf
library(RandomFields)
loadfonts()
library(knitr) # class. statistics
# library(ggplot2)
graphics.off()

# set working directory
setwd("/home/alba/ownCloud/postdoc_CRG/coding/github/cellviewer/pointpatternanalysis_SMLM/src") 

source("utilities.R")

levels1 = 'PolII'; levels2 = ''; levels = c(levels1, levels2)

# =========================
# simulated clusters as in pc-palm/thomas models
# =========================
## input parameters
num_realizations <- 10
cluster_type <- 'thomas'
area <- c(10*10*160^2, NA) # 20*20*160^2  # nm2
rho_av <- c(10*10^(-4),NA)  # average density
ntotal <- round(area*rho_av)

# # exp fitting, estimated parameters
# A <- c(18, NA)
# lambda <- c(25, NA)
# rcluster <- lambda  # average radius clusters [nm]
# Nclusters <- round(2*A*pi*rcluster^2*rho_av) # average number of proteins per cluster
# rho_cluster <-  Nclusters/(pi*rcluster^2)
# num_clusters <- round(ntotal/Nclusters)  # number of clusters

# expsq fitting, estimated parameters
A <- c(2.5, NA)
lambda <- c(6000, NA)
sigma <- sqrt(lambda)/2
kappa <- 1/(A*pi*lambda)
num_clusters <- round(kappa*area)  # number of clusters
# cluster point pattern
rcluster <- 2*sqrt(lambda)  # average radius clusters [nm]
Nclusters <- rho_av/kappa
rho_cluster <- Nclusters/(pi*rcluster^2)

# background point pattern
nbackground <- 0#round(ntotal - Nclusters*num_clusters)

phi <- rho_cluster/rho_av  # increased density of points in clusters

# simulate
for (j in 1:num_realizations){
  # # Mosaic pp
  # grid <- dirichlet(runifpoint(3000, win = square(20)))
  # logLambda <- rMosaicField(grid, rnorm, dimyx=512, rgenargs=list(mean=1, sd=1))  # mean points per pixel
  # Lambda <- exp(logLambda)
  # points <- rpoispp(Lambda)
  
  radii <- rnorm(num_clusters[1], mean = rcluster[1], sd = 0)
  centreclusters <- cbind(runif(num_clusters[1], min = max(radii), max = sqrt(area[1])-max(radii)),
                          runif(num_clusters[1], min = max(radii), max = sqrt(area[1])-max(radii)))
  pp_background <- rpoint(nbackground[1], win=owin(c(0,sqrt(area[1])), c(0,sqrt(area[1]))))
  points <- pp_background
  
  for (i in 1:num_clusters[1]){
    pp_cluster <- circle(cluster_type, n=Nclusters[1], radius=rcluster[1], centre=centreclusters[i,], sig=rcluster[1]/4)
    points <- superimpose(pp_cluster,points)
  }
  plot(points, cex=0.2, main='', pch=16, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)

  if (levels[2] != ''){
    points1 <- points %mark% factor(sample(c(levels[1],levels[2]), npoints(points), replace=TRUE, prob=c(2,3)/5))

    radii <- rnorm(num_clusters[1], mean = rcluster[1], sd = 0)
    centreclusters <- cbind(runif(num_clusters[1], min = max(radii), max = sqrt(area)-max(radii)),
                            runif(num_clusters[1], min = max(radii), max = sqrt(area)-max(radii)))
    pp_background <- rpoint(nbackground[1], win=owin(c(0,sqrt(area[1])), c(0,sqrt(area))))
    points2 <- pp_background
    for (i in 1:num_clusters){
      pp_cluster <- circle(cluster_type, n=Nclusters[1], radius=rcluster[1], 
                           centre=centreclusters[i,], sig=rcluster[1]/4)
      points <- superimpose(pp_cluster,points2)
    }
    points <- superimpose(levels1=points1, levels2=points2)
  }
  
  fileName <- paste(c('synthetic_', cluster_type, '_A', round(A), '_lambda', round(lambda), '_nt', ntotal, '_numclusters', 
                      round(num_clusters), '_', j), collapse='')
  openpdf(paste(fileName, ".pdf", sep = ''))
  plot(points, cex=0.2, main='', pch=16, cols="black", use.marks=FALSE, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
  closepdf(paste(fileName, ".pdf", sep = ''))
  savetext(matrix(c(points$x,points$y), nrow=points$n, ncol=2), paste(fileName, ".txt", sep = ''))
}

# # =========================
# # Tools in spatstat can be used to simulate such models by hand. Figure 14.29 shows examples
# # of linked Cox and balanced Cox processes, generated by
# # =========================
# P <- dirichlet(runifpoint(400, win = square(2)))
# logLambda <- rMosaicField(P, rnorm, dimyx=512, rgenargs=list(mean=4, sd=1))
# Lambda <- exp(logLambda)
# plot(Lambda, main='')
# points <- rpoispp(Lambda)
# plot(points, cex=0.4, main='', pch=16, cols="black",
#      use.marks=FALSE, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)

# Xlinked <- X %mark% factor(sample(c("a","b"), npoints(X), replace=TRUE, prob=c(2,3)/5))
# Y <- rpoispp(100)
# Xbalanced <- Y %mark% factor(ifelse(Lambda[Y] > exp(4), "a", "b"))
# # multitype log-Gaussian Cox process, generated by
# Z1 <- log(attr(rLGCP("exp", mu=4, var=0.2, scale=.1), "Lambda"))
# Z2 <- log(attr(rLGCP("exp", 4, var=0.1, scale=.1), "Lambda"))
# 
# Lam1 <- exp(Z1)
# Lam2 <- exp((Z1 + Z2)/2)
# Xlgcp <- superimpose(a=rpoispp(Lam1), b=rpoispp(Lam2))

# # # Thomas pp
# points <- rThomas(kappa=num_clusters/area, scale=round(rcluster/3), mu=Nclusters, 
#                   win = owin(c(0,sqrt(area)), c(0,sqrt(area))),
#                   drop=TRUE, saveLambda=FALSE, saveparents=TRUE)

# # triangle
# X <- rpoint(50, win=triangle(cenx=25, ceny=25, gamma=20, rot=0,height=15))
# points <- superimpose(points,X)
# plot(points, cex=0.2, main='', pch=16, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)

# # a square
# X <- rpoint(40, win=quadrilateral(cenx=20, ceny=10, rot=130, height=1, width=1))
# points <- superimpose(points,X)
# plot(points, cex=0.2, main='', pch=16, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)

# # a rectange
# X <- rpoint(80, win=quadrilateral(cenx=10, ceny=30, rot=10, height=3, width=1))
# points <- superimpose(points,X)
# plot(points, cex=0.2, main='', pch=16, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)

# # =========================
# # one gaussian clusters
# # =========================
# area <- 5*5  # in STORM pixels
# density_c <- 200  # constant
# enrichment <- 50
# density_b <- density_c/enrichment
# nbackground <- floor(area*density_b)
# cluster_type <- "gaussian"
# pp_background <- rpoint(nbackground, win=owin(c(0,sqrt(area)), c(0,sqrt(area))))
# points <- pp_background
# radius1 <- 120/160
# pp_cluster <- circle(distribution=cluster_type, n=floor(density_c*radius1^2*pi), radius=radius1, centre=c(2.5,2.5), sig=radius1/4)
# points <- superimpose(points, pp_cluster)
# radius2 <- 20/160
# pp_cluster <- circle(distribution=cluster_type, n=10*floor(density_c*radius2^2*pi), radius=radius2, centre=c(2.35,2.35), sig=radius2/4)
# points <- superimpose(points, pp_cluster)
# radius3 <- 20/160
# pp_cluster <- circle(distribution=cluster_type, n=10*floor(density_c*radius3^2*pi), radius=radius3, centre=c(3,3), sig=radius3/4)
# points <- superimpose(points, pp_cluster)
# fileName = 'clusterincluster_test5'
# plot(points, cex=0.2, main='', pch=16, cols="black", use.marks=FALSE, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
# openpdf(paste(fileName, ".pdf", sep = ''))
# plot(points, cex=0.2, main='', pch=16, cols="black", use.marks=FALSE, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
# closepdf(paste(fileName, ".pdf", sep = ''))
# savetext(matrix(c(points$x,points$y), nrow=points$n, ncol=2), paste(fileName, ".txt", sep = ''))

# # =========================
# # multiple clusters similart to in De15
# # =========================
num_realizations <- 50
area <- 20*20  # all units: STORM pixels
num_clusters <- 10
rcluster <- c(30/160, 100/160)  # mean/s of radius/radii. Univariate or bivariate distribution
scluster <- rcluster*0  #rcluster/4 # c(0.05, 0.1)
density_c <- 325   # constant
enrichment <- 100
density_b <- density_c/enrichment
nbackground <- floor(area*density_b)
cluster_type <- "gaussian"

col_palette <-  c(rgb(173,216,230,max = 255,alpha=125), rgb(255,165,0,max = 255,alpha=125))
for (j in 1:num_realizations){
  fileName <- paste(c('synthetic_', cluster_type, '_numclusters', round(num_clusters), '_rcluster',
                      round(160*rcluster[1]), '_', round(160*rcluster[2]), '_', round(160*rcluster[3]), 
                      'nm', '_enrich', enrichment, '_densityc',
                      round(density_c), 'px2_', j), collapse='')
  
  radii <- rnorm(num_clusters, mean = rcluster, sd = scluster)
  centreclusters <- cbind(runif(num_clusters, min = 5*max(radii), max = sqrt(area)-5*max(radii)),
                          runif(num_clusters, min = 5*max(radii), max = sqrt(area)-5*max(radii)))
  pp_background <- rpoint(nbackground, win=owin(c(0,sqrt(area)), c(0,sqrt(area))))
  points <- pp_background
  openpdf(paste(fileName, ".pdf", sep = ''))
  plot(points, cex=0.1, main='', pch=16, cols="black", use.marks=FALSE, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
  points_cluster <- rpoint(0, win=owin(c(0,sqrt(area)), c(0,sqrt(area))))
  for (i in 1:num_clusters){
    Nclusters <- floor(density_c*(pi*radii[i]^2))
    pp_cluster <- circle(cluster_type, n=Nclusters, radius=radii[i], centre=centreclusters[i,], sig=radii[i]/2)
    #points_cluster <- superimpose(pp_cluster,points_cluster)
    # col <- "black"
    col <- col_palette[i%%2 + 1]
    points(pp_cluster, cex=0.1, main='', pch=16, col=col, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
    points <- superimpose(pp_cluster,points)
  }
  closepdf(paste(fileName, ".pdf", sep = ''))
  savetext(matrix(c(points$x,points$y), nrow=points$n, ncol=2), paste(fileName, ".txt", sep = ''))
}

# 
# # pixelate
# im <- pixellate(points, step=0.1)
# im <- as.im(points, dimyx=100)
# openpdf("pppixelated_triangle_square_low.pdf")
# plot(im, main='')
# closepdf("pppixelated_triangle_square_low.pdf")
# savetext(matrix(im$v, nrow=im$dim[1], ncol=im$dim[2]), 'pixelated_triangle_square.txt', ncolumns=im$dim[2])