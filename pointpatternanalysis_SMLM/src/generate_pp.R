# create point patterns
# http://mapas.mma.gov.br/i3geo/pacotes/rlib/win/spatstat/html/owin.html

### import libraries
library(spatstat)  # statistical point pattern analysis
library(car) # class. statistics
library(MASS)
library(extrafont)  # fonts for latex pdf
library(RandomFields)
loadfonts()
library(knitr) # class. statistics
# library(ggplot2)
graphics.off()

# set working directory
setwd("/home/alba/ownCloud/postdoc_CRG/coding/github/cellviewer/pointpatternanalysis_SMLM/src") 

source("utilities.R")

levels1 = 'CTCF'; levels2 = ''; levels = c(levels1, levels2)

## input parameters
num_realizations <- 10
cluster_type <- 'thomas'
area <- c(20*20*160^2, NA) # 20*20*160^2  # nm2
rho_av <- c(12*10^(-4),NA)  # average density
ntotal <- round(area*rho_av)

# exp fitting, estimated parameters
A <- c(10, NA)
lambda <- c(21, NA)
rcluster <- lambda  # average radius clusters [nm]
Nclusters <- round(2*A*pi*rcluster^2*rho_av) # average number of proteins per cluster
rho_cluster <-  Nclusters/(pi*rcluster^2)
num_clusters <- round(ntotal/Nclusters)  # number of clusters

# # expsq fitting, estimated parameters
# A <- c(7, NA)
# lambda <- c(2550, NA)
# sigma <- sqrt(lambda)/2
# kappa <- 1/(A*pi*lambda)
# num_clusters <- round(kappa*area)  # number of clusters
# # cluster point pattern
# rcluster <- 2*sqrt(lambda)  # average radius clusters [nm]
# Nclusters <- rho_av/kappa
# rho_cluster <- Nclusters/(pi*rcluster^2)

# background point pattern
nbackground <- 0#round(ntotal - Nclusters*num_clusters)

phi <- rho_cluster/rho_av  # increased density of points in clusters

# simulate
for (j in 1:num_realizations){
  # # Mosaic pp
  # grid <- dirichlet(runifpoint(3000, win = square(20)))
  # logLambda <- rMosaicField(grid, rnorm, dimyx=512, rgenargs=list(mean=1, sd=1))  # mean points per pixel
  # Lambda <- exp(logLambda)
  # points <- rpoispp(Lambda)
  
  radii <- rnorm(num_clusters[1], mean = rcluster[1], sd = 0)
  centreclusters <- cbind(runif(num_clusters[1], min = max(radii), max = sqrt(area[1])-max(radii)),
                          runif(num_clusters[1], min = max(radii), max = sqrt(area[1])-max(radii)))
  pp_background <- rpoint(nbackground[1], win=owin(c(0,sqrt(area[1])), c(0,sqrt(area[1]))))
  points <- pp_background
  
  for (i in 1:num_clusters[1]){
    pp_cluster <- circle(cluster_type, n=Nclusters[1], radius=rcluster[1], centre=centreclusters[i,], sig=rcluster[1]/4)
    points <- superimpose(pp_cluster,points)
  }
  plot(points, cex=0.2, main='', pch=16, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)

  if (levels[2] != ''){
    points1 <- points %mark% factor(sample(c(levels[1],levels[2]), npoints(points), replace=TRUE, prob=c(2,3)/5))

    radii <- rnorm(num_clusters[1], mean = rcluster[1], sd = 0)
    centreclusters <- cbind(runif(num_clusters[1], min = max(radii), max = sqrt(area)-max(radii)),
                            runif(num_clusters[1], min = max(radii), max = sqrt(area)-max(radii)))
    pp_background <- rpoint(nbackground[1], win=owin(c(0,sqrt(area[1])), c(0,sqrt(area))))
    points2 <- pp_background
    for (i in 1:num_clusters){
      pp_cluster <- circle(cluster_type, n=Nclusters[1], radius=rcluster[1], 
                           centre=centreclusters[i,], sig=rcluster[1]/4)
      points <- superimpose(pp_cluster,points2)
    }
    points <- superimpose(levels1=points1, levels2=points2)
  }
  
  fileName <- paste(c('synthetic_', cluster_type, '_A', round(A), '_lambda', round(lambda), '_nt', ntotal, '_numclusters', 
                      round(num_clusters), '_', j), collapse='')
  openpdf(paste(fileName, ".pdf", sep = ''))
  plot(points, cex=0.2, main='', pch=16, cols="black", use.marks=FALSE, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
  closepdf(paste(fileName, ".pdf", sep = ''))
  savetext(matrix(c(points$x,points$y), nrow=points$n, ncol=2), paste(fileName, ".txt", sep = ''))
}


# # Tools in spatstat can be used to simulate such models by hand. Figure 14.29 shows examples
# # of linked Cox and balanced Cox processes, generated by
# P <- dirichlet(runifpoint(100, win = square(2)))
# logLambda <- rMosaicField(P, rnorm, dimyx=512, rgenargs=list(mean=4, sd=1))
# Lambda <- exp(logLambda)
# X <- rpoispp(Lambda)
# Xlinked <- X %mark% factor(sample(c("a","b"), npoints(X), replace=TRUE, prob=c(2,3)/5))
# Y <- rpoispp(100)
# Xbalanced <- Y %mark% factor(ifelse(Lambda[Y] > exp(4), "a", "b"))
# # multitype log-Gaussian Cox process, generated by
# Z1 <- log(attr(rLGCP("exp", mu=4, var=0.2, scale=.1), "Lambda"))
# Z2 <- log(attr(rLGCP("exp", 4, var=0.1, scale=.1), "Lambda"))
# 
# Lam1 <- exp(Z1)
# Lam2 <- exp((Z1 + Z2)/2)
# Xlgcp <- superimpose(a=rpoispp(Lam1), b=rpoispp(Lam2))

# # # Thomas pp
# points <- rThomas(kappa=num_clusters/area, scale=round(rcluster/3), mu=Nclusters, 
#                   win = owin(c(0,sqrt(area)), c(0,sqrt(area))),
#                   drop=TRUE, saveLambda=FALSE, saveparents=TRUE)

# # triangle
# X <- rpoint(50, win=triangle(cenx=25, ceny=25, gamma=20, rot=0,height=15))
# points <- superimpose(points,X)
# plot(points, cex=0.2, main='', pch=16, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)

# # a square
# X <- rpoint(40, win=quadrilateral(cenx=20, ceny=10, rot=130, height=1, width=1))
# points <- superimpose(points,X)
# plot(points, cex=0.2, main='', pch=16, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)

# # a rectange
# X <- rpoint(80, win=quadrilateral(cenx=10, ceny=30, rot=10, height=3, width=1))
# points <- superimpose(points,X)
# plot(points, cex=0.2, main='', pch=16, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)

# 
# # pixelate
# im <- pixellate(points, step=0.1)
# im <- as.im(points, dimyx=100)
# openpdf("pppixelated_triangle_square_low.pdf")
# plot(im, main='')
# closepdf("pppixelated_triangle_square_low.pdf")
# savetext(matrix(im$v, nrow=im$dim[1], ncol=im$dim[2]), 'pixelated_triangle_square.txt', ncolumns=im$dim[2])